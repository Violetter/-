1, 树的概念 
	树(Tree)是n(n>=0)个结点有限集。在任意一颗非空树中:
	1) 有且仅有一个特定的称为根(root)的结点；
	2) 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1,T2,....Tm,其中每个集合本身
	   又是一颗树，并且称为根的子树(SubTree)。
	   
	   
	树的结点包含一个数据元素及若干指向相关子树的分支。
	
	结点的度(Degree):
		结点拥有的子树的数量称为结点的度。度为0的结点称为叶子(Leaf)结点或终端结点；
		度不为0的结点称为非终端结点或分支结点。
		
	结点的层次(Level):
		从根开始定义起，根为第一层，根的子树为第二层，树中最大层次称为该树的深度(Depth)或高度。
		
2, 二叉树(Binary Tree)是一种树型结构，它的特点是每个结点至多只有两根子树，即二叉树中不存在
	度大于2的结点。并且二叉树的子树有左、右之分，其次序不能任意颠倒。
	
	二叉树的五种形态:
		(1)空二叉树
		(2)只有一个根结点的二叉树
		(3)只有左子树
		(4)只有右子树
		(5)完全二叉树
		
3，二叉树的性质
	1) 在二叉树的第i层上至多有 2^(i-1)个结点 (i>=1)
		证明:   数学归纳法
				分裂理解
				
	2) 深度为K的二叉树至多有 2^k-1个结点
	    证明： 二进制理解
		
	3) 对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，
		则 n2 = n0-1
		
		满二叉树: 一棵深度为K且具有2^K-1个结点的二叉树，称为满二叉树
				(在不改变其深度的情况下，不能再往这棵树上增加结点了)
		完全二叉树: 满足以下两个条件的二叉树
			a. 去除最后一层后为满二叉树
			b. 最后一层的结点必须依次从左往右挂载
	
	4) 具有n个结点的完全二叉树的深度为 (log2 N)+1 向下取整
	
	5) 具有n个结点的完全二叉树的，如果自上而下，自左到右，从1到n编号，那么:
		编号为i的结点，它的左子结点(如果有)的编号为2i，其右子结点(如果有)的
		编号为2i+1,它的父结点(如果有)编号为i/2。
		
4，二叉树的存储结构
	(1)顺序存储结构
		把一棵普通的二叉树，填补成一棵完全二叉树，然后按自上而下，从左到右，用1~n编号，
		保存在一个数组里。
		#define MAX_TREE_SIZE 1024
		typedef char TElemType;
		TElemType SqBiTree[MAX_TREE_SIZE];
		
	(2)链式存储结构
	
		typedef struct BiTNode
		{
			TElemType data;//数据域
			struct BiTNode *lchild, *rchild;//指针域
		}BiTNode;
		
5，二叉树的遍历
	如何按某条搜索路径访问树中的每个结点，使得每个结点均被访问一次，且只访问一次。
	"访问"的含义很广，可以是对某个结点做某种操作。可能是读操作，也可能是写操作，也可能是删除等。
	
	先序遍历:  根、左、右 
	中序遍历:  左、根、右
	后序遍历:  左、右、根
	
	1) 先序、中序、后序是针对根来讲的;
	2) 若这里"左"、"右"不是终端结点，则会进入递归遍历，但是每次操作的都是“根”。
	
	用二叉树实现中缀表达式转后缀表达式:
		中缀表达式方便人们的理解与计算，而后缀表达式更方便计算机的运算
			
			a+b*c  ==>  abc*+ 
			中缀        后缀
			
	那么如何中缀表达式转化为后缀表达式呢？
		如: a+b*c+(d*e+f)*g   
		
		==> 转化为二叉树
		(1) 叶子结点都是操作数
		(2) 非叶子结点都是运算符
		(3) 树根的运算符优先级最低
		
		通过后序遍历得到后缀表达式
		a+b*c+(d*e+f)*g   ==>  abc*+de*f+g*+

6，二叉排序树(Binary Sort Tree)
	二叉排序树有名二叉查找树，它要么是一棵空树，要么是具有下列性质的二叉树
	1) 若它的左子树不为空，则左子树上所有的结点的值均小于它的根结点；
	2) 若它的右子树不为空，则右子树上所有的结点的值均大于它的根结点；
	3) 它的左右子树若存在，也分别为二叉排序树。
	
7, 平衡二叉树(Balanced Binary Tree)
	平衡二叉树又称为AVL树。它要么是一棵空树，要么是具有以下性质的二叉排序树:
	1) 它的左子树或右子树都是平衡二叉树
	2) 左子树和右子树的深度之差的绝对值不超过1 (1,0,-1)
	
	若将二叉树的结点的平衡因子BF(Balance Factor)定义为该结点的左子树的深度减去
	右子树的深度，则平衡二叉树的所有结点的平衡因子只可能是 -1,0,1。只要二叉树
	上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。
	
		typedef struct AVLNode
		{
			TElemType data;
			struct AVLNode *Left,*Right;
			int Height;//空树的高度为0
		}AVLNode;
		
	建立AVL树的过程中，把不平衡的树转换成一个平衡树有四种方式:
	(1) 单向右旋平衡处理 SingleRotateWithRight
	(2) 单向左旋平衡处理 SingleRotateWithLeft
	(3) 双向旋转(先左后右)平衡处理  DoubleRotateLeftRight
	(4) 双向旋转(先右后左)平衡处理  DoubleRotateRightLeft
	
8, 哈弗曼树
	1，基本概念
	哈弗曼树又称最优二叉树。它是n个带权叶子结点构成的所有二叉树中，带权路径长度WPL最小的二叉树。
	(1)一棵树的带权路径长度定义为： 树中所有叶子结点的带权路径长度之和。
	(2)结点的带权路径长度规定为从树根结点到该结点之间的路径长度与该结点上的权的乘积。
	
	2，哈夫曼编码
	在电报通信中，电文是以二进制0/1序列传送的，每个字符对应一个二进制编码。为了缩短电文
	的总长度，采用不等长的编码方式，使用频率高的用短编码，使用频率低的用长编码。
	
	我们把使用频率作为权值，每个字符作为叶子结点来构建哈夫曼树，然后每个分支结点的左右分支
	分别用0和1编码，这样就得到了每个叶子结点的二进制编码:
		a: 00
		b: 01
		c: 100
		d: 1010
		e: 1011
		f: 11
		
		发送bcd的编码是 011001010，且只有唯一的解读方式
		
	3，构建哈夫曼树
		假设有n个权值分别为w1,w2,w3,...wn的叶子结点，则哈夫曼树的构造规则为:
		
		第一步: 构建森林
			我们把每一个叶子，都当做一颗独立的树(只有根结点)，这样就形成了一个森林。
			我们把这片森林存放到一个优先队列中，方便取出最小的结点。
			
		第二步:
			从优先队列中取出权值最小的两个结点，然后再创建一个新的结点作为他们的父结点，
			父结点的权值就是这两个结点权值之和
		
		第三步： 把新的创建的父结点加入到优先队列。
			重复第二、三步，直到优先队列中只剩下一个结点为止，该结点就是哈夫曼树的根结点
	
	
	
	
	
	
	
	
	
	
	
	作业:
		1, 把今天的内容消化记忆
		2, 判断完全二叉树
		   判断一个指定的二叉树是不是完全二叉树。是打印yes，不是打印no
			提示: 层次遍历
			
	作业:
		1, 把今天的内容理解消化
		2, 寻找共同父结点
			在一棵二叉树(不一定是二叉排序树)中，找到两个结点的共同父结点
			提示:
				1）先序遍历
				2）如果有一个结点是另外一个结点的父结点，那么它就是共同的父节点
				3）这两个结点一定分别在父节点的左右子树中。
			
		
		
		
		 
		
		