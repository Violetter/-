1，图论
	定义: 图(Graph)是一种非线性数据结构，形式化描述为:
		Graph = (V, R)
		其中V={Vi|Vi属于datatype,i=0,1,2...n-1}是图中元素Vi(称为顶点Vertex)的集合，
		当n=0，V为空集。
		
		R={<Vi,Vj>|Vi,Vj属于V，且Vi，Vj之间存在路径，0<=i,j<=n-1}是顶点之间的关系集，
		<Vi,Vj>为顶点Vi,Vj之间是否存在路径的判断条件。即若Vi,Vj之间的路径存在，则关系
		<Vi,Vj>属于R。
		
		
	有向图(Digraph) : 弧
	无向图(Undigraph): 边
	
	网: 若在图的关系<Vi,Vj>或<Vj,Vi>上附加一个值W，称为W为弧(边)上的权。
	    带权的图称为网。(权W的具体含义视在不同领域的应用而定，如顶点表示城市，
		权W的具体含义视在不同领域的应用而定，如顶点表示城市，权W可以为两个城市
		间的距离等等)。
		
	顶点的度: 顶点的边或弧的条数。
		有向图的顶点则有入度和出度之分。
		
	路径: 一个顶点到另外一个顶点的方式
		两顶点存在路径说明是连通的，若任意两顶点都是连通的，则图就是连通图。
		有向的则称为强连通图。
		
2，图的存储结构:
	
	"数组表示法" "逆邻接表" "十字链表" ...
	
	1）数组表示法，又名 邻接矩阵(Adjacency matrix)
		G = (V, R)
		
	  可以用两个数组来存储图G：
	  一个数组存储G的顶点集V，另外一个二维数组存储G中顶点间的关系集R，该二维数组就是
	  所谓的邻接矩阵。
	  
	  #define MAXN 64
	  typedef char Vtype;//顶点的数据类型
	  typedef int  Adjtype;//邻接矩阵的类型，其实就是边的权值类型
	  
	  typedef struct
	  {
		Vtype V[MAXN];//顶点集合，一维数组
		Adjtype Adj[MAXN][MAXN];//边的集合，用二维数组表示，即邻接矩阵
		int vexnum;//保存图中顶点的个数
		int arcnum;//保存图中边的条数
	  }mgraph;
	  
	2）邻接表
		所谓邻接表(Adjacency Lists),是将图中的每一个顶点V和由V出发的弧或边构成一个单链表。
		邻接表是图的一种链式存储结构。
		
		struct adj;//邻接结点的数据类型
		{
			int termIndex;//边的结点在顶点数组中的下标
			int w;权值
			struct adj *next;
		};
		
		struct Vertex //起始结点的数据类型 
		{
			Vtype data;//顶点的值
			struct adj *first;//指向第一个数据结点
		};
		
		struct Vertex graph[MAXN];//起始结点数组
		
	3）逆邻接表
		逆邻接表顾名思义，和邻接表是正好相反的，逆邻接表每一个顶点作为链表的头结点，
		后继结点所存储的是能够直接到该顶点的相邻顶点。
		
	4）十字链表 
		十字链表是“邻接表”与“逆邻接表”的结合。
		
3, 图的遍历 
	图的遍历是树的遍历的推广，是按照某种规划(或次序)访问图中各顶点一次且仅一次的操作，
	亦是将网状结构按某种规划线性化的过程。
	
	对图的遍历通常有"深度优先搜索"和"广度优先搜索"的方法，二者是现代人工智能(AI)的基础。
	
	1,深度优先搜索算法(DFS: Depth First Search)
		设初始化时，图中的各顶点均未被访问，从图中某个顶点(设为V0)出发，访问V0，
		然后搜索V0的一个邻接点Vi,若Vi未被访问，则访问之，再搜索Vi的一个邻接点(深度优先),..
		若某顶点的邻接点全部访问完毕。则回溯(Backtracking)到它上一个顶点，然后再从此顶点
		又按深度优先的方法搜索下去，...直到能访问的顶点都访问完毕为止。
		
	2,广度优先搜索算法(BFS: Breadth First Search)
		类似树的按层次遍历，初始时，图中各顶点均未被访问，从图中某个顶点(设V0)出发，访问V0，
		并依次访问V0的各个邻接点(广度优先)，然后，再分别从这些被访问过的顶点出发，仍按照
		广度优先的策略搜索其他顶点，。。。直到能访问的顶点都访问完毕为止。
	
4，最短路径问题

	解决带权有向图中两顶点间最短路径问题有两个经典算法:
	Dijkstra(迪杰斯特拉)算法和Floyd(弗洛伊德)算法 
	
	Dijkstra算法：是解决从网络中任一顶点(源点)出发，求它到其他各顶点(终点)的最短路径。
	
	算法思路: 按路径长度递增次序产生从某源点v到图中其余各个顶点的最短路径。
	
	Dijkstra算法需要用到两个辅助向量
	(1)向量 S[n]
		S[i]=1 表示从源点v到该点Vi的最短路径已经求出来了
		S[i]=0 表示从源点v到该点Vi的最短路径还没有求出来
		初始时，S[v]=1,其他S[i]=0(0<=i<=n-1,i不等于v)
	(2)向量 dist[n]
		dist[i]存放从源点v到vi这个顶点的当前最短路径长度
		初始时 
			当V可以直接到Vi,dist[i] = <V,vi>的权W 
			当V不可以直接到Vi,dist[i] = 无穷大
			
	算法步骤:
		显然，从源点v到其他各顶点的最短路径中第一短的，
		一定是能直接到的顶点(邻接点)里最短的。
	step1:
		从源点v到其他各顶点的当前最短路径中找出最短的
		dist[u] = min{dist[w]|w=0,1,2,3...n-1,且S[w]==0}
	step2:
		用当前最优路径去更新其他路径
		对 S[w]==0的w， 如果 dist[u]+<u,w> < dist[w]
		==> dist[w] = dist[u]+<u,w>
		
	然后重复 step1,step2，直到所有的顶点的最短路径都求出来了。
	
	
5，最小生成树
	
	生成树：在一个连通图中找一个连通子图，是它包含图中全部的n个顶点，且没有环。
			可证该树有且仅有n-1条边。
			
	最小生成树: 在连通图的所有生成树中，所有边的权累加和最小的生成树。
	
	应用: n个城市修电网
	
	最小生成树算法:  普里姆算法(Prim)
		普里姆算法是一种贪心算法。先定义一个结构体数组close_edge保存生成树里的边，
		用来筛选出当前权最小的边。
		
			struct Assis_array
			{
				int start;//边的起点
				int end;//边的终点
				int weight;//边的权
			}close_edge[MAXN];
			
		step1: 从出发点v1开始，把V1到各个顶点的边保存到close_edge数组里，然后再把
			close_edge数组中下标为V1的元素的weight赋值为-1,表示该顶点已经在最小生成树中。
			
		step2: 在close_edge数组中筛选出权最小的边(权不为1)的元素，把该元素的终点作为
			当前最优顶点，把该元素的weight赋值为-1
		step3: 用当前最优顶点到其他顶点的权去更新数组 close_edge。
		
		重复 step2,step3
			
			

	作业: 用二维链表保存 每个叶子结点的哈夫曼编码
	  
	  
		
		
		