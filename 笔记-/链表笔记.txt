问题引入: 我们在使用数组时，数组一旦定义好了，则数组的长度就不能修改。
	缺陷: a. 造成内存资源的浪费
	      b. 不能完全保证分配的空间够用
		  c. 插入和删除元素比较麻烦
		  
	==>按需分配，且能灵活的插入和删除元素 ==> 链表
	
	
新内容，却是老面孔：因为链表就是由一个或多个结构体通过指针指向关系构成的。
	我们先看下这样的一种结构体类型(带指针成员)
	定义该结构体变量方式:
		1, 栈(局部变量): 生存期随代码块持续性，同一作用域里的变量名不同重复
		2, 堆(malloc)：生存期随进程持续性，只需要用指针变量保存地址
		
概念: 链表就是由一个或多个含有指针成员变量的结构体变量，通过其指针成员的地址
	  指向，形成的一种逻辑上的链式数据结构。
	  
	  我们把每个结构体变量称为该链表的结点(node)。
	  
	首结点(head): 链表中唯一一个只指向别的结点，而不被其他结点指向的结点。
			首结点的地址就是整个链表的首地址。
	尾结点(tail): 链表中唯一一个只被别的结点指向，而不指向其他结点的结点。
			尾结点的next成员保存的NULL。
	(注意：这只是单向链表中)
	
因此，(1)只要知道首结点的地址，则其他结点的数据都可以被访问
	  (2)如果要保存新的数据，则需要再创一个结点并赋值添加进链表即可。
	  
链表的创建步骤:
	1）每需要保存一份数据，就创建一个新的结点
	2）把数据写入新结点
	3）把新结点加入到链表中
	
创建过程:
	1）从无到有：第一个结点的诞生，此时首结点和尾结点都是它本身
	2）从少到多: 在后面添加(尾插法)
	             在前面添加(头插法)
				 
尾插法: 新结点接在尾结点的后面，即尾结点指向新结点，
		然后尾结点被新结点替代。
		特点: 先链入的结点在前面，后链入的结点在后面
头插法: 新结点接在首结点的前面，即新结点指向首结点，
		然后首结点被新结点替代。
		特点：后链入的结点在前面，先链入的结点在后面
		
		
作业1:
	1, 把今天的内容理解消化并记忆
	2, 创建有序链表
	
		/*
			
			eg:  输入 3 4 2 1 6 5 0
			  ==>  1 2 3 4 5 6 
			create_sort_list: 根据用户的输入创建一个有序单链表，输入0结束
			@retval: 返回链表的首地址
			  
			提示:
				从少到多: 找置位插，第一个比它大的节点，插在它前面
		*/
		struct node *create_sort_list(void)
		
		班级_姓名_作业名
		2366315864@qq.com
		
作业2:
	1, 把今天的内容理解消化并记忆 ==> 拆的用法
	2, 归并两有序链表
		把两个有序的链表合成一个有序的链表
		/*
			
			eg:  listA: 1 2 4 5 7
			     listB: 3 6 8 9
			==>
				 listC: 1 2 3 4 5 6 7 8 9
				  
			struct List *merge_two_lists(struct List *listA, struct List *listB)
		*/
		
		
	练习: 求两有序链表的交集,且把重复的去掉
			eg:  listA: 2 2 3 4 7 8
			     listB: 1 2 2 4 8 9
				 listC: 2 4 8
				 
			struct List *common_of_lists(struct List *listA, struct List *listB)
		
	
作业2:
	1, 把今天的内容理解消化并记忆 ==> 双向链表的操作
	2, 判断子链表
		
		有两个无序的链表A,B，判断链表B是否是A的子链表，是打印yes，不是打印no
		A: 4 2 3 3 3 4 6 5
		B: 3 3 4
		==> YES
		
		
		班级_姓名_作业名
		2366315864@qq.com
	
	
	
	